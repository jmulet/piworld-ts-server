 
import * as fs from 'fs';
import * as path from 'path';
import { getConnection } from 'typeorm';
import { MetadataStorage } from 'class-validator/metadata/MetadataStorage';
import { ColumnMetadata } from 'typeorm/metadata/ColumnMetadata';
import { EntityMetadata } from 'typeorm/metadata/EntityMetadata';
import { config } from '../../server.config';
import { getFromContainer } from 'class-validator';
 
const NUMBER_TYPES = ['int', 'tinyint', 'float'];
const STRING_TYPES = ['text', 'longtext', 'varchar'];
const DATE_TYPES = ['date', 'datetime', 'timestamp'];

function toTSType(sqlType: string): string {
    if (NUMBER_TYPES.indexOf(sqlType) >= 0) {
        return "number";
    } else if (STRING_TYPES.indexOf(sqlType) >= 0) {
        return "string";
    } else if (DATE_TYPES.indexOf(sqlType) >= 0) {
        return "Date";
    }
    return "any";
}
 
export function clientModelsGenerator() {
    const Entities = {};

    const lookupDirs = ["", "pda", "classroom", "books"];
    lookupDirs.forEach((subdir) => {
        let normalizedPath = path.join(__dirname, "../entities/"+subdir);
        fs.readdirSync(normalizedPath).forEach(function(file) {
            if(path.extname(file) === ".ts") {
                const name = file.replace(".ts","");
                Entities[name] = require("../entities/" + (subdir? (subdir+"/"): "") + file)[name];
            }       
        });
    });
    if (!Entities) {
        return;
    }
    const entityNames = Object.keys(Entities);
    console.log("Entities in app:: ", entityNames.join("; "));
    if (!entityNames.length) {
        return;
    }

    // Inspect metadata from entities --> Generate client entities .js files
    getConnection().entityMetadatas.forEach((entityMetadata: EntityMetadata) => {
        if (entityNames.indexOf(entityMetadata.name) < 0) {
            // Skip entities outside this app
            return;
        }       
        console.log("**** Entity: ", entityMetadata.name);
        let entity = {
            properties: [],
            defaultObject: {}
        }

        entityMetadata.columns.forEach((columnMetadata: ColumnMetadata) => {
            /*
            console.log("\tColumn: ", columnMetadata.propertyName);
            console.log("\tType: ", columnMetadata.type);
            console.log("\tNullable: ", columnMetadata.isNullable);
            console.log("\tAutogenerated: ", columnMetadata.isGenerated);
            console.log("\tDefault value: ", columnMetadata.default, typeof(columnMetadata.default));
            */
            entity.properties.push({
                name: columnMetadata.propertyName, type: columnMetadata.type, nullable: columnMetadata.isGenerated,
                generated: columnMetadata.isGenerated
            })
            entity.defaultObject[columnMetadata.propertyName] = columnMetadata.default !== undefined ? columnMetadata.default : null;
        });

        // Now load validation metadata
       
        const clazz = Entities[entityMetadata.name];
         
        const instanceClazz = new clazz()
        const validationStorage = getFromContainer(MetadataStorage);
                  
        const validationMeta = validationStorage.getTargetValidationMetadatas(clazz, config.database);
        //console.log("Validation meta", validationMeta);
        
        validationMeta.forEach( (e) => {
            const property = entity.properties.filter( (x) => x.name === e.propertyName )[0];
       
            if (property) {
                if (!property.validation) {
                    property.validation = [];
                }
                let type = e.type;
                if (type === "customValidation") {
                    if(e.constraintCls) {
                        type = e.constraintCls.name;
                    }
                }
                if (type !== "customValidation" && type !== "conditionalValidator") {
                    property.validation.push({type: type, constraints: e.constraints});
                }
            }
        });
         
        console.log("Building js and ts files");
        let builderJS = [];
        let builderTS = [];
        builderJS.push("module.exports = " + JSON.stringify(entity, null, 2) + ";");

        builderTS.push(`
        /* Changing or deleting this line will produce this entity to be out of sync */
        import { FormGroup, FormBuilder, FormControl, Validators } from '@angular/forms';

        export class `+ entityMetadata.name +` {`);
         
        entity.properties.forEach( (p) => {
            const type = toTSType(p.type);
            let defProp = "\t\t\t" + p.name + ":" + type;
            const defaultVal = entity.defaultObject[p.name];
            if (defaultVal != null && typeof defaultVal != "function") {
               defProp += " = ";
               if (type==='string') {
                   defProp += '"'+defaultVal+'"';
               } else {
                   defProp += defaultVal;
               }             
            }            
            builderTS.push( defProp + ";" );
        }); 
        builderTS.push(`  
            constructor() {             
            }

            setObj(obj: any) {
                if (obj) {
                    for (var key in obj) {
                        this[key] = obj[key];
                    }
                }
                return this;
            }

            toForm(fb: FormBuilder) {
                return fb.group({`);

        entity.properties.forEach( (p) => {
           let propDef = "\t\t\t\t\t'" + p.name + "': new FormControl(this." 
           + p.name;
           if (!p.generated && p.validation && p.validation.length) {
                const validatorsBuild = [];
                p.validation.forEach( (v)=> {
                    if (v.type==="isNotEmpty") {
                        validatorsBuild.push("Validators.required");
                    } else if (v.type==="MaxLength" && v.constraints[0]) {                        
                        validatorsBuild.push("Validators.maxLength(" + v.constraints[0] + ")");
                    } else if (v.type==="MinLength" && v.constraints[0]) {                        
                        validatorsBuild.push("Validators.minLength(" + v.constraints[0] + ")");
                    } else if (v.type==="Min" && v.constraints[0]) {                        
                        validatorsBuild.push("Validators.min(" + v.constraints[0] + ")");
                    } else if (v.type==="Max" && v.constraints[0]) {                        
                        validatorsBuild.push("Validators.max(" + v.constraints[0] + ")");
                    } else if (v.type==="isEmail") {   
                        validatorsBuild.push("Validators.pattern(\"[a-zA-Z0-9._-]+[@]+[a-zA-Z0-9-]+[.]+[a-zA-Z]{2,6}\")");
                    } else if (v.type==="customValidation" ) {
                        // do something
                    }

                }); 
                if (validatorsBuild.length > 1) {
                    propDef += ", Validators.compose([" + validatorsBuild.join(",")+ "]) )";
                } else if (validatorsBuild.length === 1) {
                    propDef += ", " + validatorsBuild[0] + ")";
                } else {
                    propDef += ")";     
                }
                
           } else {
               propDef += ")";
           }
           builderTS.push(propDef + ",");
        });
        
        builderTS.push(`});
            }
        }`);


        var directory = path.join(global.__publicDir, "../../src/entities/" + entityMetadata.name);
        
        //fs.writeFileSync(directory + ".js", builderJS.join("\n")); 
        fs.writeFileSync(directory + ".ts", builderTS.join("\n")); 

        console.log("> Generated entity for client to " + directory);

    });
    return entityNames;
}