import * as path from 'path';
import 'es6-shim';
import 'reflect-metadata';

import { getFromContainer, MetadataStorage, useContainer as cvUseContainer } from 'class-validator';
import { useContainer as routingUseContainer, useExpressServer } from 'routing-controllers';
import { Container } from 'typedi';
import { createConnection, useContainer as ormUseContainer } from 'typeorm';
import { ColumnMetadata } from 'typeorm/metadata/ColumnMetadata';
import { EntityMetadata } from 'typeorm/metadata/EntityMetadata';

import { ErrorMdw } from './server/middlewares/ErrorMdw';
import { NotFoundMdw } from './server/middlewares/NotFoundMdw';
import { appServer } from './server/server';
import { config } from './server/server.config';
import { BootstrapSrv } from './server/services/BootstrapSrv';

import * as Entities from './server/entities';
import * as fs from 'fs'; 

// set up container for dependency-injection
routingUseContainer(Container);
ormUseContainer(Container);
//cvUseContainer(Container);


createConnection({
    type: "mysql",
    host: config.mysql.host,
    port: config.mysql.port,
    username: config.mysql.username,
    password: config.mysql.password,
    database: config.mysql.database,
    entities: [
        __dirname + "/server/entities/*.js",
        __dirname + "/server/entities/**/*.js",
        __dirname + "/server/entities/*.ts",
        __dirname + "/server/entities/**/*.ts"
    ],
    synchronize: true,
    logging: true
}).then(async connection => {

    // reuses express app, registers all controller routes 
    useExpressServer(appServer.app, {
        defaultErrorHandler: false,
        // we specify controllers we want to use
        controllers: [
            __dirname + "/server/controllers/*.ts",
            __dirname + "/server/controllers/*.js",
            __dirname + "/server/controllers/**/*.ts",
            __dirname + "/server/controllers/**/*.js",
        ],
        middlewares: [
            NotFoundMdw,
            ErrorMdw
        ],
        routePrefix: config.basePrefix,
        validation: false // Disable validation by default
    });

    // Finally show all routes
    console.log("Mounted routes: ");
    appServer.app._router.stack.forEach(function (e) {
        if (e.route) {
            console.log(e.route.path);
        }
    });

    console.log("Entities", Entities);

    // Inspect metadata from entities --> Generate client entities .js files
    connection.entityMetadatas.forEach((entityMetadata: EntityMetadata) => {
        console.log("**** Entity: ", entityMetadata.name);
        let entity = {
            properties: [],
            defaultObject: {}
        }

        entityMetadata.columns.forEach((columnMetadata: ColumnMetadata) => {
            /*
            console.log("\tColumn: ", columnMetadata.propertyName);
            console.log("\tType: ", columnMetadata.type);
            console.log("\tNullable: ", columnMetadata.isNullable);
            console.log("\tAutogenerated: ", columnMetadata.isGenerated);
            console.log("\tDefault value: ", columnMetadata.default, typeof(columnMetadata.default));
            */
            entity.properties.push({
                name: columnMetadata.propertyName, type: columnMetadata.type, nullable: columnMetadata.isGenerated,
                generated: columnMetadata.isGenerated
            })
            entity.defaultObject[columnMetadata.propertyName] = columnMetadata.default !== undefined ? columnMetadata.default : null;
        });

        // Now load validation metadata
       
        const clazz = Entities[entityMetadata.name];
       
        const validationMeta = getFromContainer(MetadataStorage).getTargetValidationMetadatas(clazz, config.database);
        validationMeta.forEach( (e) => {
            const property = entity.properties.filter( (x) => x.name === e.propertyName )[0];
       
            if (property) {
                if (!property.validation) {
                    property.validation = [];
                }
                let type = e.type;
                if (type === "customValidation") {
                    if(e.constraintCls) {
                        type = e.constraintCls.name;
                    }
                }
                if (type !== "customValidation" && type !== "conditionalValidator") {
                    property.validation.push({type: type, constraints: e.constraints});
                }
            }
        });

        let builder = [];
        builder.push("var pwApp = window.pwApp || {};");
        builder.push("pwApp.entities = pwApp.entities || {};");
        builder.push("pwApp.entities['" + entityMetadata.name + "'] = " + JSON.stringify(entity, null, 2) + ";");
        var directory = path.join(__dirname, "./client/public/assets/entities/" + entityMetadata.name + ".js");
        fs.writeFileSync(directory, builder.join("\n")); 
        console.log("> Generated entity for client to " + directory);
    });
 
    // Do extra integrity checks on database before starting up server
    const bootstrapSrv = Container.get(BootstrapSrv);

    bootstrapSrv.doChecks().then((r) => {
        if (r.errors) {
            console.log(r.errors);
            process.exit(1);
        } else {
            appServer.app.listen(config.express.port);
            console.log("piWorld-springjs application server is up and running on port " + config.express.port);
        }
    });



}).catch(error => {
    console.log("TypeORM connection error: ", error);
    process.exit(1);
});

